<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Retro Platformer — 3 Levels</title>
  <style>
    body {margin:0;background:#000;color:#fff;font-family:monospace;display:flex;flex-direction:column;align-items:center;}
    .hud {margin:10px;}
    canvas {image-rendering:pixelated;border:2px solid #fff;background:#111;}
    button {margin-top:10px;padding:5px 10px;font-family:monospace;}
    .panel {display:flex;justify-content:space-around;width:90%;margin-top:10px;}
    .card {border:1px solid #fff;padding:5px;font-size:12px;}
    .overlay {position:absolute;inset:0;display:flex;align-items:center;justify-content:center;color:#fff;font-family:monospace;font-size:16px;text-align:center;pointer-events:none;}
  </style>
</head>
<body>
  <div class="hud">
    <span id="levelText">Level: 1 / 3</span> | 
    <span id="timeText">00:00.000</span>
    <button id="restartBtn">Restart</button>
  </div>
  <div style="position:relative;">
    <canvas id="game" width="900" height="520"></canvas>
    <div id="overlay" class="overlay"></div>
  </div>
  <div class="panel">
    <div class="card">
      <h3>Leaderboard</h3>
      <ol id="leaderboard"></ol>
    </div>
    <div class="card">Controls: ← → move, ↑/W/Space jump (double jump enabled)</div>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();
    socket.on('connect', () => {
      console.log('Connected to server', socket.id);
    });

    const canvas=document.getElementById('game');
    const ctx=canvas.getContext('2d');
    const W=canvas.width,H=canvas.height;

    const player={x:60,y:0,w:20,h:20,vx:0,vy:0,onGround:false,jumpsUsed:0}; // square player
    const GRAVITY=0.8,SPEED=6,JUMP_V=-14;

    function makeDot(x,y){return{x,y,hitR:18,collected:false};}

    const levels=[
      {spawn:{x:60,y:380},plats:[{x:0,y:480,w:900,h:40,color:'rgb(85,85,85)'},{x:140,y:420,w:160,h:20,color:'rgb(85,85,85)'},{x:360,y:360,w:120,h:20,color:'rgb(85,85,85)'},{x:560,y:300,w:160,h:20,color:'rgb(85,85,85)'},{x:760,y:260,w:100,h:20,color:'rgb(85,85,85)'}],dots:[makeDot(180,400),makeDot(420,340),makeDot(600,280),makeDot(800,240)]},
      {spawn:{x:40,y:420},plats:[{x:0,y:480,w:900,h:40,color:'rgb(85,85,85)'},{x:120,y:420,w:100,h:20,color:'rgb(85,85,85)'},{x:280,y:370,w:120,h:20,color:'rgb(85,85,85)'},{x:470,y:420,w:120,h:20,color:'rgb(85,85,85)'},{x:640,y:360,w:120,h:20,color:'rgb(85,85,85)'},{x:820,y:300,w:80,h:20,color:'rgb(85,85,85)'},{x:740,y:240,w:60,h:20,color:'rgb(85,85,85)'}],dots:[makeDot(160,400),makeDot(320,350),makeDot(520,400),makeDot(680,340),makeDot(850,280)]},
      {spawn:{x:60,y:440},plats:[{x:0,y:480,w:900,h:40,color:'rgb(85,85,85)'},{x:120,y:430,w:90,h:20,color:'rgb(85,85,85)'},{x:240,y:380,w:90,h:20,color:'rgb(85,85,85)'},{x:360,y:330,w:90,h:20,color:'rgb(85,85,85)'},{x:480,y:280,w:90,h:20,color:'rgb(85,85,85)'},{x:600,y:230,w:90,h:20,color:'rgb(85,85,85)'},{x:720,y:185,w:120,h:20,color:'rgb(85,85,85)'},{x:820,y:145,w:60,h:20,color:'rgb(85,85,85)'}],dots:[makeDot(150,410),makeDot(270,360),makeDot(390,310),makeDot(510,260),makeDot(630,210),makeDot(760,170),makeDot(850,130)]}
    ];

    let levelIdx=0,firstMoveArmed=true,timerStart=null,timerEnd=null;

    const keys=new Set();
    const startKeys=new Set(['ArrowLeft','ArrowRight','KeyA','KeyD','Space','KeyW','ArrowUp']);

    window.addEventListener('keydown',e=>{
      keys.add(e.code);
      if(firstMoveArmed&&levelIdx===0&&startKeys.has(e.code)){
        firstMoveArmed=false;timerStart=performance.now();timerEnd=null;overlay("");
      }
      if(['Space','KeyW','ArrowUp'].includes(e.code)){
        if(player.onGround){
          spawnJumpTriangles();
          player.vy=JUMP_V;
          player.onGround=false;
          player.jumpsUsed=1;
        } else if(player.jumpsUsed<2){
          // double jump
          player.vy=JUMP_V;
          player.jumpsUsed++;
          particles.push({x:player.x+player.w/2,y:player.y+player.h+2,w:player.w+6,alpha:1}); // wider line
        }
      }
    });
    window.addEventListener('keyup',e=>keys.delete(e.code));

    const timeText=document.getElementById('timeText');
    const levelText=document.getElementById('levelText');
    const overlayEl=document.getElementById('overlay');
    function fmt(ms){if(ms==null)return'00:00.000';const t=Math.floor(ms);const m=Math.floor(t/60000);const s=Math.floor((t%60000)/1000);const ms3=String(t%1000).padStart(3,'0');return`${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}.${ms3}`;}
    function updateTimerUI(){const t=timerEnd??(timerStart?performance.now()-timerStart:0);timeText.textContent=fmt(t);} 
    function overlay(msg){overlayEl.textContent=msg;}

    const LB_KEY='retroPlatformerLB';
    function loadLB(){try{return JSON.parse(localStorage.getItem(LB_KEY))||[]}catch{return[]}}
    function saveLB(a){localStorage.setItem(LB_KEY,JSON.stringify(a));}
    function pushTime(ms){
      const name=prompt("You finished! Enter your name for the leaderboard:","Player");
      if(!name) return;
      const arr=loadLB();
      arr.push({ms,name});
      arr.sort((a,b)=>a.ms-b.ms);
      while(arr.length>5)arr.pop();
      saveLB(arr);
      renderLB();
    }
    function renderLB(){
      const arr=loadLB();
      document.getElementById('leaderboard').innerHTML=arr.map((x,i)=>`<li>${x.name}: ${fmt(x.ms)}</li>`).join('')||'<li>No times yet</li>';
    }

    function currentLevel(){return levels[levelIdx];}
    function resetToSpawn(){const lvl=currentLevel();player.x=lvl.spawn.x;player.y=lvl.spawn.y;player.vx=0;player.vy=0;player.onGround=false;player.jumpsUsed=0;}
    function loadLevel(i){levelIdx=i;levelText.textContent=`Level: ${levelIdx+1} / ${levels.length}`;resetToSpawn();if(levelIdx===0){firstMoveArmed=true;timerStart=null;timerEnd=null;overlay('PRESS ANY MOVE KEY TO START');}else overlay('');}

    function aabb(a,b){return!(a.x+a.w<=b.x||a.x>=b.x+b.w||a.y+a.h<=b.y||a.y>=b.y+b.h);}
    function resolve(px,py,vx,vy){const lvl=currentLevel();const box={x:px,y:py,w:player.w,h:player.h};let onGround=false;for(const r of lvl.plats){if(!aabb(box,r))continue;const dx1=(r.x+r.w)-box.x,dx2=(box.x+box.w)-r.x,dy1=(r.y+r.h)-box.y,dy2=(box.y+box.h)-r.y;const penX=Math.min(dx1,dx2),penY=Math.min(dy1,dy2);if(penX<penY){if(dx1<dx2){box.x=r.x+r.w;}else{box.x=r.x-box.w;}vx=0;}else{if(dy1<dy2){box.y=r.y+r.h;vy=Math.max(0,vy);}else{box.y=r.y-box.h;vy=0;onGround=true;}}}if(box.x<0){box.x=0;vx=0;}if(box.x+box.w>W){box.x=W-box.w;vx=0;}return{x:box.x,y:box.y,vx,vy,onGround};}

    const particles=[];
    const triangles=[];

    function spawnJumpTriangles(){
      const lvl=currentLevel();
      for(const r of lvl.plats){
        if(player.x+player.w>r.x && player.x<r.x+r.w && Math.abs(player.y+player.h-r.y)<5){
          const count=3+Math.floor(Math.random()*3);
          for(let i=0;i<count;i++){
            const side=(player.x+player.w/2<r.x+r.w/2)?-1:1;
            const angle=(Math.random()*0.5+0.25)*Math.PI*side;
            triangles.push({
              x:player.x+player.w/2,
              y:r.y,
              size:4+Math.random()*3,
              alpha:1,
              dx:Math.cos(angle)*1.5,
              dy:-Math.random()*1.5-0.5,
              color:r.color
            });
          }
          break;
        }
      }
    }

    function tick(){
      const left=keys.has('ArrowLeft')||keys.has('KeyA');
      const right=keys.has('ArrowRight')||keys.has('KeyD');

      if(left) player.vx=-SPEED; else if(right) player.vx=SPEED; else player.vx=0;

      player.vy+=GRAVITY;
      let nx=player.x+player.vx,ny=player.y+player.vy;
      const r=resolve(nx,ny,player.vx,player.vy);
      player.x=r.x;player.y=r.y;player.vx=r.vx;player.vy=r.vy;player.onGround=r.onGround;if(player.onGround)player.jumpsUsed=0;
      if(player.y>H+200)resetToSpawn();

      const lvl=currentLevel();
      for(const d of lvl.dots){if(d.collected)continue;const dx=(player.x+player.w/2)-d.x,dy=(player.y+player.h/2)-d.y;if(dx*dx+dy*dy<d.hitR*d.hitR){d.collected=true;}}
      if(lvl.dots.every(d=>d.collected)){
        if(levelIdx<levels.length-1)loadLevel(levelIdx+1);
        else{
          if(!timerEnd&&timerStart){
            timerEnd=performance.now()-timerStart;
            pushTime(timerEnd);
          }
          overlay(`FINISHED ${fmt(timerEnd)}`);
        }
      }

      for(const p of particles){p.y+=2;p.alpha-=0.05;}while(particles.length&&particles[0].alpha<=0)particles.shift();
      for(const t of triangles){t.x+=t.dx;t.y+=t.dy;t.alpha-=0.04;}while(triangles.length&&triangles[0].alpha<=0)triangles.shift();

      draw();updateTimerUI();requestAnimationFrame(tick);
    }

    function draw(){
      ctx.clearRect(0,0,W,H);
      ctx.fillStyle='#000';ctx.fillRect(0,0,W,H);
      for(const r of currentLevel().plats){ctx.fillStyle=r.color;ctx.fillRect(r.x,r.y,r.w,r.h);} 
      ctx.fillStyle='red';for(const d of currentLevel().dots)if(!d.collected)ctx.fillRect(d.x-3,d.y-3,6,6);
      ctx.fillStyle='#fff';ctx.fillRect(player.x,player.y,player.w,player.h);
      for(const p of particles){ctx.fillStyle=`rgba(255,255,255,${p.alpha})`;ctx.fillRect(p.x-p.w/2,p.y,p.w,2);}
      for(const t of triangles){
        ctx.fillStyle=`rgba(85,85,85,${t.alpha})`;
        ctx.beginPath();
        ctx.moveTo(t.x,t.y);
        ctx.lineTo(t.x+t.size,t.y+t.size);
        ctx.lineTo(t.x-t.size,t.y+t.size);
        ctx.closePath();
        ctx.fill();
      }
    }

    document.getElementById('restartBtn').addEventListener('click',()=>{loadLevel(0);renderLB();});
    function init(){renderLB();loadLevel(0);resetToSpawn();requestAnimationFrame(tick);}init();
  </script>
</body>
</html>
